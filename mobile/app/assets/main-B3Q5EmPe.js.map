{"version":3,"file":"main-B3Q5EmPe.js","sources":["../../src/utils/constants.ts","../../src/services/ApiService.ts","../../src/services/WebRTCService.ts","../../src/services/AudioService.ts","../../src/services/SessionManager.ts","../../src/components/UIController.ts","../../src/components/MicButtonController.ts","../../src/components/App.ts","../../src/services/StateManager.ts","../../src/main.ts","../../src/utils/dom.ts"],"sourcesContent":["// API Configuration\nexport const API_ENDPOINTS = {\n  WP_USER_ME: '/wp-json/wp/v2/users/me',\n  REALTIME_SESSION: '/wp-json/ai-commander/v1/realtime/session',\n  REALTIME_TOOL: '/wp-json/ai-commander/v1/realtime/tool',\n  READ_TEXT: '/wp-json/ai-commander/v1/read-text',\n} as const;\n\nexport const OPENAI_API = {\n  REALTIME_URL: 'https://api.openai.com/v1/realtime',\n  DEFAULT_MODEL: 'gpt-4o-realtime-preview-2024-12-17',\n} as const;\n\n// Audio Configuration\nexport const AUDIO_CONFIG = {\n  SAMPLE_RATE: 48000,\n  CHANNEL_COUNT: 1,\n  SAMPLE_SIZE: 16,\n  ECHO_CANCELLATION: false,\n  NOISE_SUPPRESSION: false,\n  AUTO_GAIN_CONTROL: false,\n  MAX_BITRATE: 96000,\n} as const;\n\n// UI Configuration\nexport const UI_CONFIG = {\n  ERROR_DISPLAY_DURATION: 5000,\n  MOBILE_AUDIO_CHECK_INTERVAL: 100,\n  SCROLL_BEHAVIOR: 'smooth' as const,\n} as const;\n\n// Storage Keys\nexport const STORAGE_KEYS = {\n  SITE_URL: 'inofficina_site_url',\n  USERNAME: 'inofficina_username',\n  APP_PASSWORD: 'inofficina_app_password',\n} as const;\n\n// Status Messages\nexport const STATUS_MESSAGES = {\n  disconnected: 'Premi per iniziare',\n  connecting: 'Connessione in corso...',\n  recording: 'In ascolto...',\n  processing: 'Elaborazione...',\n  speaking: 'Risposta in corso...',\n  speaking_interruptible: 'Premi per interrompere',\n  tool_wait: 'Esecuzione comando...',\n  idle: 'In attesa...',\n  error: 'Errore',\n} as const;\n\n// Error Messages\nexport const ERROR_MESSAGES = {\n  INVALID_URL: 'URL non valido. Inserisci un URL completo (es. https://www.tuaofficina.it)',\n  INVALID_CREDENTIALS: 'Credenziali non valide. Verifica nome utente e password.',\n  ACCESS_DENIED: 'Accesso negato. Verifica i permessi utente sul sito.',\n  CONNECTION_FAILED: 'Impossibile connettersi al sito WordPress',\n  SESSION_FAILED: 'Impossibile avviare la sessione',\n  TOOL_EXECUTION_FAILED: 'Tool execution failed',\n  NETWORK_ERROR: 'Network error',\n  DATA_CHANNEL_NOT_OPEN: 'Data channel not open',\n  TTS_FAILED: 'Errore nella riproduzione audio personalizzato.',\n  COMMUNICATION_ERROR: 'Errore di comunicazione',\n  UNKNOWN_ERROR: 'Errore sconosciuto',\n} as const;\n","import { API_ENDPOINTS, ERROR_MESSAGES } from '@/utils/constants';\nimport { SessionResponse, ToolExecutionRequest, ToolExecutionResponse } from '@/types';\n\nexport class ApiService {\n  constructor(\n    private siteUrl: string,\n    private bearerToken: string\n  ) {}\n\n  async testConnection(): Promise<void> {\n    const response = await fetch(`${this.siteUrl}${API_ENDPOINTS.WP_USER_ME}`, {\n      method: 'GET',\n      mode: 'cors',\n      credentials: 'omit',\n      headers: {\n        Authorization: `Basic ${this.bearerToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      if (response.status === 401) {\n        throw new Error(ERROR_MESSAGES.INVALID_CREDENTIALS);\n      } else if (response.status === 403) {\n        // In multisite, status 403 might be normal\n        try {\n          const userData = await response.json();\n          if (userData && userData.id && userData.name) {\n            console.log('Authentication successful despite 403 status');\n          } else {\n            throw new Error(ERROR_MESSAGES.ACCESS_DENIED);\n          }\n        } catch (jsonError) {\n          throw new Error(ERROR_MESSAGES.ACCESS_DENIED);\n        }\n      } else {\n        throw new Error(ERROR_MESSAGES.CONNECTION_FAILED);\n      }\n    }\n  }\n\n  async createSession(): Promise<SessionResponse> {\n    const response = await fetch(`${this.siteUrl}${API_ENDPOINTS.REALTIME_SESSION}`, {\n      method: 'POST',\n      credentials: 'omit',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Basic ${this.bearerToken}`,\n      },\n      body: JSON.stringify({}),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`${ERROR_MESSAGES.SESSION_FAILED}: ${error}`);\n    }\n\n    const sessionData = await response.json();\n    if (!sessionData.client_secret?.value) {\n      throw new Error('Invalid session response');\n    }\n\n    return sessionData;\n  }\n\n  async executeTool(request: ToolExecutionRequest): Promise<ToolExecutionResponse> {\n    const response = await fetch(`${this.siteUrl}${API_ENDPOINTS.REALTIME_TOOL}`, {\n      method: 'POST',\n      credentials: 'omit',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Basic ${this.bearerToken}`,\n      },\n      body: JSON.stringify(request),\n    });\n\n    const result = await response.json();\n    return result;\n  }\n\n  async getTextToSpeech(text: string): Promise<Blob> {\n    const response = await fetch(`${this.siteUrl}${API_ENDPOINTS.READ_TEXT}`, {\n      method: 'POST',\n      credentials: 'omit',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Basic ${this.bearerToken}`,\n      },\n      body: JSON.stringify({ text }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`TTS request failed with status ${response.status}`);\n    }\n\n    return await response.blob();\n  }\n\n  static generateBearerToken(username: string, appPassword: string): string {\n    const credentials = `${username}:${appPassword}`;\n    return btoa(credentials);\n  }\n}\n","import { OPENAI_API, AUDIO_CONFIG } from '@/utils/constants';\nimport { RealtimeEvent } from '@/types';\n\nexport interface WebRTCCallbacks {\n  onDataChannelOpen?: () => void;\n  onDataChannelMessage?: (event: MessageEvent) => void;\n  onDataChannelError?: (error: Event) => void;\n  onTrack?: (event: RTCTrackEvent) => void;\n}\n\nexport class WebRTCService {\n  private peerConnection: RTCPeerConnection | null = null;\n  private dataChannel: RTCDataChannel | null = null;\n  private localStream: MediaStream | null = null;\n\n  async startSession(\n    sessionToken: string,\n    model: string = OPENAI_API.DEFAULT_MODEL,\n    callbacks: WebRTCCallbacks = {}\n  ): Promise<void> {\n    // Create RTCPeerConnection\n    this.peerConnection = new RTCPeerConnection();\n\n    // Setup remote audio handler\n    if (callbacks.onTrack) {\n      this.peerConnection.ontrack = callbacks.onTrack;\n    }\n\n    // Increase bitrate to 96kb/s\n    this.peerConnection.getTransceivers().forEach((t) => {\n      if (t.sender.track?.kind === 'audio') {\n        const params = t.sender.getParameters();\n        params.encodings = [{ maxBitrate: AUDIO_CONFIG.MAX_BITRATE }];\n        t.sender.setParameters(params);\n      }\n    });\n\n    // Get user media\n    this.localStream = await navigator.mediaDevices.getUserMedia({\n      audio: {\n        sampleRate: AUDIO_CONFIG.SAMPLE_RATE,\n        channelCount: AUDIO_CONFIG.CHANNEL_COUNT,\n        sampleSize: AUDIO_CONFIG.SAMPLE_SIZE,\n        echoCancellation: AUDIO_CONFIG.ECHO_CANCELLATION,\n        noiseSuppression: AUDIO_CONFIG.NOISE_SUPPRESSION,\n        autoGainControl: AUDIO_CONFIG.AUTO_GAIN_CONTROL,\n      },\n    });\n\n    // Add tracks to peer connection\n    this.localStream.getTracks().forEach((track) => {\n      this.peerConnection!.addTrack(track, this.localStream!);\n    });\n\n    // Create data channel\n    this.dataChannel = this.peerConnection.createDataChannel('oai-events', {\n      ordered: true,\n    });\n\n    if (callbacks.onDataChannelOpen) {\n      this.dataChannel.onopen = callbacks.onDataChannelOpen;\n    }\n\n    if (callbacks.onDataChannelMessage) {\n      this.dataChannel.onmessage = callbacks.onDataChannelMessage;\n    }\n\n    if (callbacks.onDataChannelError) {\n      this.dataChannel.onerror = callbacks.onDataChannelError;\n    }\n\n    // SDP negotiation\n    const offer = await this.peerConnection.createOffer();\n    await this.peerConnection.setLocalDescription(offer);\n\n    const sdpResponse = await fetch(`${OPENAI_API.REALTIME_URL}?model=${model}`, {\n      method: 'POST',\n      body: offer.sdp,\n      headers: {\n        Authorization: `Bearer ${sessionToken}`,\n        'Content-Type': 'application/sdp',\n      },\n    });\n\n    if (!sdpResponse.ok) {\n      throw new Error(`SDP negotiation failed: ${sdpResponse.status}`);\n    }\n\n    const answerSdp = await sdpResponse.text();\n    await this.peerConnection.setRemoteDescription({\n      type: 'answer',\n      sdp: answerSdp,\n    });\n  }\n\n  sendEvent(event: RealtimeEvent): void {\n    if (!this.dataChannel || this.dataChannel.readyState !== 'open') {\n      throw new Error('Data channel not open');\n    }\n    this.dataChannel.send(JSON.stringify(event));\n  }\n\n  muteMicrophone(): void {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach((track) => {\n        track.enabled = false;\n      });\n    }\n  }\n\n  unmuteMicrophone(): void {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach((track) => {\n        track.enabled = true;\n      });\n    }\n  }\n\n  updateTurnDetection(mode: 'server_vad' | 'none'): void {\n    console.log(`[WebRTCService] updateTurnDetection called with mode:`, mode);\n    const event: RealtimeEvent = {\n      type: 'session.update',\n      session: {\n        turn_detection:\n          mode === 'server_vad'\n            ? {\n                type: 'server_vad',\n                threshold: 0.5,\n                prefix_padding_ms: 300,\n                silence_duration_ms: 200,\n              }\n            : null,\n      },\n    };\n    console.log('[WebRTCService] Sending session.update event:', event);\n    this.sendEvent(event);\n  }\n\n  closeSession(): void {\n    if (this.localStream) {\n      this.localStream.getTracks().forEach((track) => track.stop());\n      this.localStream = null;\n    }\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n  }\n}\n","import { ERROR_MESSAGES } from '@/utils/constants';\nimport { ApiService } from './ApiService';\n\nexport class AudioService {\n  private isMobileAudioUnlocked = false;\n  private globalAudioContext: AudioContext | null = null;\n  private isPlayingCustomTts = false;\n  private currentAudioElement: HTMLAudioElement | null = null;\n\n  constructor(private apiService: ApiService) {}\n\n  /**\n   * Unlocks mobile audio playback by resuming AudioContext and performing\n   * a muted play/pause cycle on the audio element\n   */\n  unlockMobileAudio(audioElement: HTMLAudioElement): void {\n    if (this.isMobileAudioUnlocked) return;\n    this.isMobileAudioUnlocked = true;\n\n    // Ensure an AudioContext is running\n    try {\n      this.globalAudioContext =\n        this.globalAudioContext ||\n        new (window.AudioContext ||\n          (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext)();\n      if (this.globalAudioContext.state === 'suspended') {\n        this.globalAudioContext.resume();\n      }\n    } catch (error) {\n      console.warn('AudioContext initialisation failed:', error);\n    }\n\n    // Perform a muted play/pause cycle to satisfy autoplay policies\n    if (audioElement) {\n      const wasMuted = audioElement.muted;\n      audioElement.muted = true;\n\n      const playPromise = audioElement.play();\n      if (playPromise && typeof playPromise.then === 'function') {\n        playPromise\n          .then(() => {\n            audioElement.pause();\n            audioElement.currentTime = 0;\n            audioElement.muted = wasMuted;\n            console.log('[AI-Commander] Mobile audio unlocked');\n          })\n          .catch((err) => {\n            console.warn('Mobile audio unlock play() rejected:', err);\n            audioElement.muted = wasMuted;\n          });\n      } else {\n        audioElement.muted = wasMuted;\n      }\n    }\n  }\n\n  /**\n   * Plays custom TTS audio from the WordPress endpoint\n   */\n  async playCustomTtsAudio(\n    text: string,\n    audioElement: HTMLAudioElement,\n    onStart?: () => void,\n    onEnd?: () => void\n  ): Promise<void> {\n    if (!text) {\n      console.log('[AudioService] No text provided for TTS');\n      return;\n    }\n\n    console.log('[AudioService] Playing custom TTS for:', text);\n\n    try {\n      this.isPlayingCustomTts = true;\n      this.currentAudioElement = audioElement;\n\n      if (onStart) onStart();\n\n      console.log('[AudioService] Fetching TTS audio from API...');\n      const audioBlob = await this.apiService.getTextToSpeech(text);\n      console.log('[AudioService] Received audio blob, size:', audioBlob.size);\n\n      // Check if playback was interrupted\n      if (!this.isPlayingCustomTts || !audioElement) {\n        return;\n      }\n\n      // Prepare audio element for playback\n      if (audioElement.dataset.objectUrl) {\n        URL.revokeObjectURL(audioElement.dataset.objectUrl);\n        delete audioElement.dataset.objectUrl;\n      }\n\n      audioElement.srcObject = null;\n      const objectUrl = URL.createObjectURL(audioBlob);\n      audioElement.dataset.objectUrl = objectUrl;\n      audioElement.src = objectUrl;\n\n      await audioElement.play();\n\n      // Wait for playback to finish\n      await new Promise<void>((resolve, reject) => {\n        const checkInterrupted = () => {\n          if (!this.isPlayingCustomTts) {\n            audioElement.pause();\n            resolve();\n          }\n        };\n\n        audioElement.onended = () => resolve();\n        audioElement.onerror = () => reject(new Error('Audio playback error'));\n\n        // Check periodically if playback was interrupted\n        const intervalId = setInterval(() => {\n          checkInterrupted();\n          if (!this.isPlayingCustomTts) {\n            clearInterval(intervalId);\n          }\n        }, 100);\n\n        // Clean up interval when promise resolves\n        const originalResolve = resolve;\n        resolve = () => {\n          clearInterval(intervalId);\n          originalResolve();\n        };\n      });\n\n      // Clean up\n      URL.revokeObjectURL(objectUrl);\n      delete audioElement.dataset.objectUrl;\n    } catch (err) {\n      console.error('Error during custom TTS playback:', err);\n      throw new Error(ERROR_MESSAGES.TTS_FAILED);\n    } finally {\n      this.isPlayingCustomTts = false;\n      this.currentAudioElement = null;\n      if (onEnd) onEnd();\n    }\n  }\n\n  /**\n   * Interrupts ongoing custom TTS playback\n   */\n  interruptCustomTts(): void {\n    if (this.isPlayingCustomTts && this.currentAudioElement) {\n      this.isPlayingCustomTts = false;\n      this.currentAudioElement.pause();\n      this.currentAudioElement.currentTime = 0;\n\n      if (this.currentAudioElement.dataset.objectUrl) {\n        URL.revokeObjectURL(this.currentAudioElement.dataset.objectUrl);\n        delete this.currentAudioElement.dataset.objectUrl;\n      }\n\n      console.log('Custom TTS interrupted by user');\n    }\n  }\n\n  /**\n   * Cleans up audio resources\n   */\n  cleanup(audioElement: HTMLAudioElement): void {\n    this.interruptCustomTts();\n\n    if (audioElement) {\n      audioElement.pause();\n      audioElement.currentTime = 0;\n      audioElement.srcObject = null;\n      audioElement.src = '';\n\n      if (audioElement.dataset.objectUrl) {\n        URL.revokeObjectURL(audioElement.dataset.objectUrl);\n        delete audioElement.dataset.objectUrl;\n      }\n\n      audioElement.onended = null;\n    }\n  }\n\n  get isPlayingTts(): boolean {\n    return this.isPlayingCustomTts;\n  }\n}\n","import { StateManager } from './StateManager';\nimport { ApiService } from './ApiService';\nimport { WebRTCService } from './WebRTCService';\nimport { AudioService } from './AudioService';\nimport {\n  RealtimeEvent,\n  ToolCall,\n  ResponseDoneEvent,\n  TranscriptionEvent,\n  DeltaEvent,\n  ErrorEvent,\n} from '@/types';\nimport { ERROR_MESSAGES } from '@/utils/constants';\n\nexport class SessionManager {\n  private webrtcService: WebRTCService;\n  private audioService: AudioService;\n\n  constructor(\n    private stateManager: StateManager,\n    private apiService: ApiService,\n    private audioElement: HTMLAudioElement\n  ) {\n    this.webrtcService = new WebRTCService();\n    this.audioService = new AudioService(apiService);\n  }\n\n  async startSession(): Promise<void> {\n    try {\n      // Batch state updates to avoid multiple notifications\n      this.stateManager.setState({\n        status: 'connecting',\n        messages: [],\n        toolCallQueue: [],\n        currentToolCallId: null,\n      });\n\n      // Get session token from WordPress\n      const sessionData = await this.apiService.createSession();\n      this.stateManager.setSessionData(\n        sessionData.client_secret.value,\n        sessionData.modalities || ['text', 'audio']\n      );\n\n      console.log('Session modalities:', sessionData.modalities);\n      console.log('Custom TTS enabled:', !sessionData.modalities?.includes('audio'));\n\n      // Start WebRTC session\n      await this.webrtcService.startSession(sessionData.client_secret.value, sessionData.model, {\n        onDataChannelOpen: () => {\n          this.stateManager.updateStatus('recording');\n        },\n        onDataChannelMessage: (event) => this.handleServerEvent(event),\n        onDataChannelError: (error) => {\n          console.error('Data channel error:', error);\n          this.handleError(ERROR_MESSAGES.COMMUNICATION_ERROR);\n        },\n        onTrack: (event) => {\n          if (this.audioElement && event.streams && event.streams[0]) {\n            this.audioElement.srcObject = event.streams[0];\n            this.audioElement.play().catch((e) => console.error('Audio play error:', e));\n          }\n        },\n      });\n    } catch (error) {\n      console.error('Session start error:', error);\n      this.handleError((error as Error).message || ERROR_MESSAGES.SESSION_FAILED);\n      this.stopSession();\n    }\n  }\n\n  stopSession(): void {\n    // Interrupt any ongoing custom TTS playback\n    if (this.stateManager.getState().isPlayingCustomTts) {\n      this.audioService.interruptCustomTts();\n    }\n\n    this.webrtcService.closeSession();\n    this.audioService.cleanup(this.audioElement);\n    this.stateManager.updateStatus('disconnected');\n    this.stateManager.updateTranscript('');\n  }\n\n  setVadEnabled(enabled: boolean): void {\n    console.log(`[SessionManager] setVadEnabled called with:`, enabled);\n    try {\n      this.webrtcService.updateTurnDetection(enabled ? 'server_vad' : 'none');\n      console.log(`[SessionManager] VAD ${enabled ? 'enabled' : 'disabled'} - session update sent`);\n      \n      // When re-enabling VAD after press-to-talk, commit the audio buffer and create response\n      if (enabled) {\n        console.log('[SessionManager] Committing audio buffer after press-to-talk');\n        this.webrtcService.sendEvent({\n          type: 'input_audio_buffer.commit'\n        });\n        \n        // Create a response after committing the buffer\n        console.log('[SessionManager] Creating response after press-to-talk');\n        this.webrtcService.sendEvent({\n          type: 'response.create'\n        });\n      }\n    } catch (error) {\n      console.error('[SessionManager] Failed to update VAD:', error);\n    }\n  }\n\n  private async handleServerEvent(event: MessageEvent): Promise<void> {\n    try {\n      const data: RealtimeEvent = JSON.parse(event.data);\n      console.log('Server event:', data.type, data);\n\n      const state = this.stateManager.getState();\n\n      switch (data.type) {\n        case 'input_audio_buffer.speech_started':\n          this.webrtcService.unmuteMicrophone();\n          this.stateManager.updateStatus('recording');\n          break;\n\n        case 'input_audio_buffer.speech_stopped':\n          this.stateManager.updateStatus('processing');\n          break;\n\n        case 'conversation.item.input_audio_transcription.completed':\n          this.stateManager.addMessage({\n            type: 'user',\n            content: (data as TranscriptionEvent).transcript,\n          });\n          break;\n\n        case 'response.created':\n          this.stateManager.updateTranscript('');\n          break;\n\n        case 'response.audio_transcript.delta':\n        case 'response.text.delta':\n          this.stateManager.appendTranscript((data as DeltaEvent).delta || '');\n          break;\n\n        case 'response.audio.delta':\n          if (!state.isCustomTtsEnabled) {\n            this.stateManager.updateStatus('speaking');\n          }\n          break;\n\n        case 'response.function_call_arguments.delta':\n          // Only update to tool_wait if not already in that state\n          if (state.status !== 'tool_wait') {\n            this.stateManager.updateStatus('tool_wait');\n          }\n          break;\n\n        case 'response.done':\n          await this.handleResponseDone(data as ResponseDoneEvent);\n          break;\n\n        case 'output_audio_buffer.stopped':\n          if (!state.isCustomTtsEnabled) {\n            this.stateManager.updateStatus('idle');\n          }\n          break;\n\n        case 'error':\n          console.error('API Error:', data);\n          this.handleError((data as ErrorEvent).message || ERROR_MESSAGES.UNKNOWN_ERROR);\n          break;\n      }\n    } catch (error) {\n      console.error('Error parsing server event:', error);\n    }\n  }\n\n  private async handleResponseDone(data: ResponseDoneEvent): Promise<void> {\n    // Clear typing indicator\n    this.stateManager.updateTranscript('');\n\n    if (data.response.status === 'failed') {\n      this.stateManager.updateStatus('error');\n      return;\n    }\n\n    const responseOutput = data.response?.output?.[0]?.content?.[0];\n    const responseText = responseOutput?.text || responseOutput?.transcript;\n\n    if (responseText) {\n      this.stateManager.addMessage({ type: 'assistant', content: responseText });\n    }\n\n    // If custom TTS is enabled, synthesize and play audio now\n    const state = this.stateManager.getState();\n    if (state.isCustomTtsEnabled && responseText) {\n      await this.playCustomTts(responseText);\n    }\n\n    // Handle function calls\n    if (data.response.output) {\n      data.response.output.forEach((outputItem) => {\n        if (\n          outputItem.type === 'function_call' &&\n          outputItem.call_id &&\n          outputItem.name &&\n          outputItem.arguments\n        ) {\n          this.stateManager.queueToolCall({\n            name: outputItem.name,\n            arguments: outputItem.arguments,\n            call_id: outputItem.call_id,\n          });\n        }\n      });\n    }\n\n    // Process tool calls if any\n    const toolCall = this.stateManager.dequeueToolCall();\n    if (toolCall) {\n      await this.processToolCall(toolCall);\n    }\n  }\n\n  private async playCustomTts(text: string): Promise<void> {\n    console.log('[SessionManager] Starting custom TTS for text:', text);\n    try {\n      await this.audioService.playCustomTtsAudio(\n        text,\n        this.audioElement,\n        () => {\n          console.log('[SessionManager] Custom TTS started');\n          this.stateManager.setPlayingCustomTts(true);\n          this.stateManager.updateStatus('speaking');\n          this.webrtcService.muteMicrophone();\n        },\n        () => {\n          console.log('[SessionManager] Custom TTS ended');\n          const state = this.stateManager.getState();\n          if (state.status !== 'disconnected') {\n            this.stateManager.setPlayingCustomTts(false);\n            this.webrtcService.unmuteMicrophone();\n            this.stateManager.updateStatus('recording');\n          }\n        }\n      );\n    } catch (error) {\n      console.error('Custom TTS error:', error);\n      if (this.stateManager.getState().status !== 'disconnected') {\n        this.handleError(ERROR_MESSAGES.TTS_FAILED);\n      }\n    }\n  }\n\n  private async processToolCall(toolCall: ToolCall): Promise<void> {\n    // Status is already set to 'tool_wait' when receiving function_call_arguments.delta\n    try {\n      const result = await this.apiService.executeTool({\n        tool_name: toolCall.name,\n        arguments: toolCall.arguments,\n      });\n\n      if (!result.error) {\n        this.sendFunctionResult(toolCall.call_id, result);\n      } else {\n        this.sendFunctionResult(toolCall.call_id, {\n          error: true,\n          message: result.message || ERROR_MESSAGES.TOOL_EXECUTION_FAILED,\n        });\n      }\n    } catch (error) {\n      this.sendFunctionResult(toolCall.call_id, {\n        error: true,\n        message: ERROR_MESSAGES.NETWORK_ERROR,\n      });\n    }\n\n    // Process next tool call if any\n    const nextToolCall = this.stateManager.dequeueToolCall();\n    if (nextToolCall) {\n      await this.processToolCall(nextToolCall);\n    }\n  }\n\n  private sendFunctionResult(callId: string, result: unknown): void {\n    try {\n      // Send function result\n      this.webrtcService.sendEvent({\n        type: 'conversation.item.create',\n        item: {\n          type: 'function_call_output',\n          call_id: callId,\n          output: JSON.stringify(result),\n        },\n      });\n\n      // Request response\n      this.webrtcService.sendEvent({\n        type: 'response.create',\n      });\n    } catch (error) {\n      this.handleError(ERROR_MESSAGES.DATA_CHANNEL_NOT_OPEN);\n    }\n  }\n\n  interruptTts(): void {\n    if (this.stateManager.getState().isPlayingCustomTts) {\n      this.audioService.interruptCustomTts();\n    } else {\n      this.stopSession();\n    }\n  }\n\n  private handleError(message: string): void {\n    console.error('Error:', message);\n    this.stateManager.updateStatus('error');\n  }\n}\n","import { UIElements, Message } from '@/types';\nimport { UI_CONFIG } from '@/utils/constants';\n\nexport class UIController {\n  private typingMessageDiv: HTMLDivElement | null = null;\n\n  constructor(private elements: UIElements) {}\n\n  showConfigScreen(): void {\n    this.elements.configScreen.style.display = 'flex';\n    this.elements.mainApp.classList.remove('active');\n  }\n\n  showMainApp(): void {\n    this.elements.configScreen.style.display = 'none';\n    this.elements.mainApp.classList.add('active');\n  }\n\n  showError(message: string): void {\n    this.elements.configError.textContent = message;\n    this.elements.configError.style.display = 'block';\n    setTimeout(() => {\n      this.elements.configError.style.display = 'none';\n    }, UI_CONFIG.ERROR_DISPLAY_DURATION);\n  }\n\n  showLoading(show: boolean): void {\n    this.elements.loadingOverlay.style.display = show ? 'flex' : 'none';\n  }\n\n  toggleSettingsMenu(): void {\n    this.elements.settingsMenu.classList.toggle('active');\n  }\n\n  hideSettingsMenu(): void {\n    this.elements.settingsMenu.classList.remove('active');\n  }\n\n  clearMessages(): void {\n    this.elements.chatContainer.innerHTML = '';\n    this.elements.chatContainer.appendChild(this.elements.emptyState);\n  }\n\n  addMessage(message: Message): void {\n    if (this.elements.emptyState.parentNode) {\n      this.elements.emptyState.remove();\n    }\n\n    const messageDiv = document.createElement('div');\n    messageDiv.className = `chat-message ${message.type}`;\n\n    const bubbleDiv = document.createElement('div');\n    bubbleDiv.className = 'message-bubble';\n    bubbleDiv.textContent = message.content;\n\n    messageDiv.appendChild(bubbleDiv);\n    this.elements.chatContainer.appendChild(messageDiv);\n\n    // Scroll to bottom\n    this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;\n  }\n\n  showTypingIndicator(): void {\n    if (this.elements.emptyState.parentNode) {\n      this.elements.emptyState.remove();\n    }\n\n    this.typingMessageDiv = document.createElement('div');\n    this.typingMessageDiv.className = 'chat-message assistant';\n    this.typingMessageDiv.id = 'typingMessage';\n\n    const bubbleDiv = document.createElement('div');\n    bubbleDiv.className = 'message-bubble typing';\n    bubbleDiv.innerHTML = `\n      <span class=\"typing-dot\"></span>\n      <span class=\"typing-dot\"></span>\n      <span class=\"typing-dot\"></span>\n    `;\n\n    this.typingMessageDiv.appendChild(bubbleDiv);\n    this.elements.chatContainer.appendChild(this.typingMessageDiv);\n\n    // Scroll to bottom\n    this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;\n  }\n\n  updateTypingMessage(text: string): void {\n    if (this.typingMessageDiv && text) {\n      const bubble = this.typingMessageDiv.querySelector('.message-bubble');\n      if (bubble) {\n        bubble.className = 'message-bubble';\n        bubble.textContent = text;\n\n        // Scroll to bottom\n        this.elements.chatContainer.scrollTop = this.elements.chatContainer.scrollHeight;\n      }\n    }\n  }\n\n  hideTypingIndicator(): void {\n    if (this.typingMessageDiv) {\n      this.typingMessageDiv.remove();\n      this.typingMessageDiv = null;\n    }\n  }\n\n  hasTypingIndicator(): boolean {\n    return this.typingMessageDiv !== null;\n  }\n\n  populateConfigForm(siteUrl: string, username: string): void {\n    this.elements.siteUrlInput.value = siteUrl;\n    this.elements.usernameInput.value = username;\n    this.elements.appPasswordInput.value = ''; // Don't populate password for security\n  }\n\n  clearConfigForm(): void {\n    this.elements.siteUrlInput.value = '';\n    this.elements.usernameInput.value = '';\n    this.elements.appPasswordInput.value = '';\n  }\n\n  disableConnectButton(disabled: boolean, text?: string): void {\n    this.elements.connectBtn.disabled = disabled;\n    if (text) {\n      this.elements.connectBtn.textContent = text;\n    }\n  }\n}\n","import { AppStatus } from '@/types';\nimport { STATUS_MESSAGES } from '@/utils/constants';\n\nexport interface MicButtonCallbacks {\n  onStartRecording: () => void;\n  onStopRecording: () => void;\n  onInterruptTts: () => void;\n  onPressAndHoldStart?: () => void;\n  onPressAndHoldEnd?: () => void;\n}\n\nexport class MicButtonController {\n  private currentState: AppStatus = 'disconnected';\n  private callbacks: MicButtonCallbacks;\n  private buttonElement: HTMLButtonElement;\n  private statusElement: HTMLElement;\n  private pressTimer: number | null = null;\n  private isPressAndHold: boolean = false;\n  private pressStartTime: number = 0;\n  private readonly PRESS_HOLD_DELAY = 300; // milliseconds to detect press-and-hold\n  private readonly MIN_CLICK_TIME = 50; // minimum time to consider it a click\n\n  constructor(\n    buttonElement: HTMLButtonElement,\n    statusElement: HTMLElement,\n    callbacks: MicButtonCallbacks\n  ) {\n    this.buttonElement = buttonElement;\n    this.statusElement = statusElement;\n    this.callbacks = callbacks;\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    // Click event for simple clicks\n    this.buttonElement.addEventListener('click', () => {\n      // Only handle click if it's not from a press-and-hold\n      if (!this.isPressAndHold && this.pressStartTime === 0) {\n        this.handleClick();\n      }\n    });\n\n    // Mouse events\n    this.buttonElement.addEventListener('mousedown', (e) => this.handlePressStart(e));\n    this.buttonElement.addEventListener('mouseup', (e) => this.handlePressEnd(e));\n    this.buttonElement.addEventListener('mouseleave', (e) => this.handlePressCancel(e));\n\n    // Touch events\n    this.buttonElement.addEventListener('touchstart', (e) => this.handlePressStart(e), {\n      passive: false,\n    });\n    this.buttonElement.addEventListener('touchend', (e) => this.handlePressEnd(e), {\n      passive: false,\n    });\n    this.buttonElement.addEventListener('touchcancel', (e) => this.handlePressCancel(e));\n  }\n\n  private handlePressStart(e: Event): void {\n    console.log('[MicButton] Press start event:', e.type, 'Current state:', this.currentState);\n    \n    // Only prevent default for touch events to avoid scroll\n    if (e.type === 'touchstart') {\n      e.preventDefault();\n    }\n\n    this.pressStartTime = Date.now();\n    this.isPressAndHold = false;\n\n    // Only start press-and-hold timer in recording state\n    if (this.currentState === 'recording') {\n      console.log('[MicButton] Starting press-and-hold timer (300ms)');\n      // Start timer for press-and-hold detection\n      this.pressTimer = window.setTimeout(() => {\n        this.isPressAndHold = true;\n        console.log('[MicButton] Press-and-hold ACTIVATED');\n        \n        // Add visual feedback\n        this.buttonElement.classList.add('press-and-hold');\n        \n        if (this.callbacks.onPressAndHoldStart) {\n          console.log('[MicButton] Calling onPressAndHoldStart callback');\n          this.callbacks.onPressAndHoldStart();\n        }\n      }, this.PRESS_HOLD_DELAY);\n    } else {\n      console.log('[MicButton] Not in recording state, skipping press-and-hold');\n    }\n  }\n\n  private handlePressEnd(e: Event): void {\n    const pressDuration = Date.now() - this.pressStartTime;\n    console.log('[MicButton] Press end event:', e.type, 'Duration:', pressDuration, 'ms', 'isPressAndHold:', this.isPressAndHold);\n    \n    if (e.type === 'touchend') {\n      e.preventDefault();\n    }\n\n    // Clear the timer\n    if (this.pressTimer) {\n      clearTimeout(this.pressTimer);\n      this.pressTimer = null;\n    }\n\n    // If press-and-hold was active, end it\n    if (this.isPressAndHold && this.callbacks.onPressAndHoldEnd) {\n      console.log('[MicButton] Ending press-and-hold, calling onPressAndHoldEnd callback');\n      \n      // Remove visual feedback\n      this.buttonElement.classList.remove('press-and-hold');\n      \n      this.callbacks.onPressAndHoldEnd();\n      // Reset immediately\n      this.isPressAndHold = false;\n    } else if (\n      this.pressStartTime > 0 &&\n      pressDuration >= this.MIN_CLICK_TIME &&\n      pressDuration < this.PRESS_HOLD_DELAY\n    ) {\n      // Normal click: between MIN_CLICK_TIME and PRESS_HOLD_DELAY\n      console.log('[MicButton] Normal click detected, calling handleClick()');\n      this.handleClick();\n    }\n\n    // Reset for next press\n    this.isPressAndHold = false;\n    this.pressStartTime = 0;\n  }\n\n  private handlePressCancel(_e: Event): void {\n    console.log('[MicButton] Press cancelled');\n    \n    // Clear timer and reset state if user moves away\n    if (this.pressTimer) {\n      clearTimeout(this.pressTimer);\n      this.pressTimer = null;\n    }\n\n    if (this.isPressAndHold && this.callbacks.onPressAndHoldEnd) {\n      console.log('[MicButton] Press-and-hold cancelled, calling onPressAndHoldEnd');\n      \n      // Remove visual feedback\n      this.buttonElement.classList.remove('press-and-hold');\n      \n      this.callbacks.onPressAndHoldEnd();\n    }\n\n    this.isPressAndHold = false;\n    this.pressStartTime = 0;\n  }\n\n  handleClick(): void {\n    switch (this.currentState) {\n      case 'disconnected':\n      case 'error':\n        this.callbacks.onStartRecording();\n        break;\n\n      case 'speaking':\n        this.callbacks.onInterruptTts();\n        break;\n\n      case 'recording':\n      case 'processing':\n      case 'tool_wait':\n      case 'idle':\n        this.callbacks.onStopRecording();\n        break;\n\n      case 'connecting':\n        // Do nothing while connecting\n        break;\n\n      default:\n        console.warn('Unknown mic button state:', this.currentState);\n    }\n  }\n\n  setState(newState: AppStatus, options: { message?: string } = {}): void {\n    console.log(`Mic button: ${this.currentState} → ${newState}`);\n    this.currentState = newState;\n    this.updateUI(newState, options);\n  }\n\n  private updateUI(state: AppStatus, options: { message?: string } = {}): void {\n    this.buttonElement.className = 'mic-button';\n    this.buttonElement.innerHTML = '';\n    this.buttonElement.disabled = false;\n\n    switch (state) {\n      case 'disconnected':\n        this.statusElement.textContent = STATUS_MESSAGES.disconnected;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.innerHTML = this.getMicIcon();\n        break;\n\n      case 'connecting':\n        this.statusElement.textContent = STATUS_MESSAGES.connecting;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.innerHTML = '<div class=\"spinner\"></div>';\n        this.buttonElement.disabled = true;\n        break;\n\n      case 'recording':\n        this.statusElement.textContent = STATUS_MESSAGES.recording;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.classList.add('recording');\n        this.buttonElement.innerHTML = this.getSoundWaveIcon();\n        break;\n\n      case 'processing':\n        this.statusElement.textContent = STATUS_MESSAGES.processing;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.innerHTML = '<div class=\"spinner\"></div>';\n        break;\n\n      case 'speaking':\n        this.statusElement.textContent = STATUS_MESSAGES.speaking_interruptible;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.disabled = false;\n        this.buttonElement.innerHTML = this.getStopIcon();\n        break;\n\n      case 'tool_wait':\n        this.statusElement.textContent = STATUS_MESSAGES.tool_wait;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.innerHTML = '<div class=\"spinner\"></div>';\n        break;\n\n      case 'idle':\n        this.statusElement.textContent = STATUS_MESSAGES.idle;\n        this.statusElement.className = 'status-text';\n        this.buttonElement.innerHTML = this.getStopIcon();\n        break;\n\n      case 'error':\n        this.statusElement.textContent = options.message || STATUS_MESSAGES.error;\n        this.statusElement.className = 'status-text error';\n        this.buttonElement.innerHTML = this.getMicIcon();\n        break;\n    }\n  }\n\n  private getMicIcon(): string {\n    return `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z\"/>\n        <path d=\"M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z\"/>\n      </svg>\n    `;\n  }\n\n  private getStopIcon(): string {\n    return `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <rect x=\"6\" y=\"6\" width=\"12\" height=\"12\" rx=\"2\"/>\n      </svg>\n    `;\n  }\n\n  private getSoundWaveIcon(): string {\n    return `\n      <div class=\"sound-wave\">\n        <span class=\"sound-bar\"></span>\n        <span class=\"sound-bar\"></span>\n        <span class=\"sound-bar\"></span>\n        <span class=\"sound-bar\"></span>\n        <span class=\"sound-bar\"></span>\n      </div>\n    `;\n  }\n}\n","import { UIElements, AppState } from '@/types';\nimport { StateManager } from '@/services/StateManager';\nimport { ApiService } from '@/services/ApiService';\nimport { SessionManager } from '@/services/SessionManager';\nimport { AudioService } from '@/services/AudioService';\nimport { UIController } from './UIController';\nimport { MicButtonController } from './MicButtonController';\nimport { ERROR_MESSAGES, STORAGE_KEYS } from '@/utils/constants';\n\nexport class App {\n  private uiController: UIController;\n  private micController: MicButtonController;\n  private sessionManager: SessionManager | null = null;\n  // @ts-expect-error - Used in handleConfigSubmit\n  private apiService: ApiService | null = null;\n  private audioService: AudioService | null = null;\n  private lastMessageCount = 0;\n\n  constructor(\n    private elements: UIElements,\n    private stateManager: StateManager\n  ) {\n    this.uiController = new UIController(elements);\n    this.micController = new MicButtonController(elements.micButton, elements.statusText, {\n      onStartRecording: () => this.startRecordingSession(),\n      onStopRecording: () => this.stopRecordingSession(),\n      onInterruptTts: () => this.interruptTts(),\n      onPressAndHoldStart: () => this.handlePressAndHoldStart(),\n      onPressAndHoldEnd: () => this.handlePressAndHoldEnd(),\n    });\n  }\n\n  async init(): Promise<void> {\n    // Set up event listeners first\n    this.setupEventListeners();\n\n    // Subscribe to state changes\n    this.stateManager.subscribe((state) => this.onStateChange(state));\n\n    // Check if we have saved credentials\n    const state = this.stateManager.getState();\n    if (state.siteUrl && this.generateBearerToken()) {\n      this.elements.siteUrlInput.value = state.siteUrl;\n      this.elements.usernameInput.value = state.username;\n\n      // Just show the main app without testing connection\n      // Services will be initialized on first mic button click\n      this.uiController.showMainApp();\n    } else {\n      this.uiController.showConfigScreen();\n    }\n  }\n\n  private setupEventListeners(): void {\n    // Config form submission\n    this.elements.configForm.addEventListener('submit', (e) => this.handleConfigSubmit(e));\n\n    // Settings menu\n    this.elements.settingsBtn.addEventListener('click', (e) => {\n      e.stopPropagation();\n      this.uiController.toggleSettingsMenu();\n    });\n\n    // Change configuration\n    this.elements.changeConfigBtn.addEventListener('click', () => {\n      this.uiController.hideSettingsMenu();\n      this.uiController.showConfigScreen();\n      this.uiController.populateConfigForm(\n        this.stateManager.getState().siteUrl,\n        this.stateManager.getState().username\n      );\n    });\n\n    // Logout\n    this.elements.logoutBtn.addEventListener('click', () => this.handleLogout());\n\n    // Unlock mobile audio on first mic button click\n    this.elements.micButton.addEventListener(\n      'click',\n      () => {\n        if (this.audioService) {\n          this.audioService.unlockMobileAudio(this.elements.remoteAudio);\n        }\n      },\n      { once: true }\n    );\n\n    // Close settings menu when clicking outside\n    document.addEventListener('click', (e) => {\n      if (\n        !this.elements.settingsBtn.contains(e.target as Node) &&\n        !this.elements.settingsMenu.contains(e.target as Node)\n      ) {\n        this.uiController.hideSettingsMenu();\n      }\n    });\n  }\n\n  private onStateChange(state: AppState): void {\n    // Update mic button state\n    this.micController.setState(state.status);\n\n    // Update UI based on state changes\n    if (state.currentTranscript) {\n      if (!this.uiController.hasTypingIndicator()) {\n        this.uiController.showTypingIndicator();\n      }\n      this.uiController.updateTypingMessage(state.currentTranscript);\n    } else {\n      // Hide typing indicator when transcript is cleared\n      this.uiController.hideTypingIndicator();\n    }\n\n    // Handle messages\n    if (state.messages.length !== this.lastMessageCount) {\n      if (state.messages.length === 0) {\n        // Messages were cleared\n        this.uiController.clearMessages();\n        this.lastMessageCount = 0;\n      } else if (state.messages.length > this.lastMessageCount) {\n        // New messages were added\n        const newMessages = state.messages.slice(this.lastMessageCount);\n        newMessages.forEach((msg) => this.uiController.addMessage(msg));\n        this.lastMessageCount = state.messages.length;\n      } else {\n        // Messages were removed (shouldn't happen normally)\n        // Rebuild the entire message list\n        this.uiController.clearMessages();\n        state.messages.forEach((msg) => this.uiController.addMessage(msg));\n        this.lastMessageCount = state.messages.length;\n      }\n    }\n  }\n\n  private generateBearerToken(): boolean {\n    const storedPassword = localStorage.getItem(STORAGE_KEYS.APP_PASSWORD);\n    const state = this.stateManager.getState();\n\n    if (state.username && storedPassword) {\n      const bearerToken = ApiService.generateBearerToken(state.username, storedPassword);\n      this.stateManager.setState({ bearerToken });\n      return true;\n    }\n    return false;\n  }\n\n  private async handleConfigSubmit(e: Event): Promise<void> {\n    e.preventDefault();\n\n    const url = this.elements.siteUrlInput.value.trim();\n    const username = this.elements.usernameInput.value.trim();\n    const appPassword = this.elements.appPasswordInput.value.trim();\n\n    if (!url || !username || !appPassword) return;\n\n    // Validate URL\n    try {\n      const validUrl = new URL(url);\n      if (!validUrl.protocol.startsWith('http')) {\n        throw new Error('URL deve iniziare con http:// o https://');\n      }\n    } catch (error) {\n      this.uiController.showError(ERROR_MESSAGES.INVALID_URL);\n      return;\n    }\n\n    // Generate bearer token\n    const bearerToken = ApiService.generateBearerToken(username, appPassword);\n\n    // Test connection\n    this.uiController.disableConnectButton(true, 'Connessione...');\n\n    try {\n      const apiService = new ApiService(url, bearerToken);\n      await apiService.testConnection();\n\n      // Save configuration\n      const cleanUrl = url.replace(/\\/$/, ''); // Remove trailing slash\n      this.stateManager.setSiteConfig(cleanUrl, username, bearerToken);\n      localStorage.setItem(STORAGE_KEYS.APP_PASSWORD, appPassword);\n\n      // Initialize services\n      await this.initializeServices(cleanUrl, bearerToken);\n\n      this.uiController.showMainApp();\n    } catch (error) {\n      this.uiController.showError(\n        (error as Error).message || 'Impossibile connettersi. Verifica i dati e riprova.'\n      );\n    } finally {\n      this.uiController.disableConnectButton(false, 'Connetti');\n    }\n  }\n\n  private handleLogout(): void {\n    if (confirm('Vuoi disconnetterti e cancellare le credenziali salvate?')) {\n      this.stateManager.clearSiteConfig();\n      this.uiController.clearConfigForm();\n      this.uiController.hideSettingsMenu();\n      this.uiController.showConfigScreen();\n      this.stopRecordingSession();\n    }\n  }\n\n  private async startRecordingSession(): Promise<void> {\n    // Initialize services if not already done\n    if (!this.sessionManager) {\n      const state = this.stateManager.getState();\n      if (!state.siteUrl || !state.bearerToken) {\n        this.uiController.showError('Credenziali non trovate. Accedi nuovamente.');\n        this.uiController.showConfigScreen();\n        return;\n      }\n\n      try {\n        this.uiController.showLoading(true);\n        await this.initializeServices(state.siteUrl, state.bearerToken);\n      } catch (error) {\n        console.error('Failed to initialize services:', error);\n        this.uiController.showLoading(false);\n        this.uiController.showError('Sessione scaduta. Accedi nuovamente.');\n        this.uiController.showConfigScreen();\n        return;\n      }\n    }\n\n    // Show loading while starting session\n    this.uiController.showLoading(true);\n\n    try {\n      await this.sessionManager!.startSession();\n    } catch (error) {\n      console.error('Failed to start session:', error);\n    } finally {\n      this.uiController.showLoading(false);\n    }\n  }\n\n  private stopRecordingSession(): void {\n    if (this.sessionManager) {\n      this.sessionManager.stopSession();\n    }\n    this.uiController.hideTypingIndicator();\n  }\n\n  private interruptTts(): void {\n    if (this.sessionManager) {\n      this.sessionManager.interruptTts();\n    }\n  }\n\n  private handlePressAndHoldStart(): void {\n    console.log('[App] handlePressAndHoldStart called, sessionManager exists:', !!this.sessionManager);\n    if (this.sessionManager) {\n      this.sessionManager.setVadEnabled(false);\n    } else {\n      console.log('[App] No sessionManager available');\n    }\n  }\n\n  private handlePressAndHoldEnd(): void {\n    console.log('[App] handlePressAndHoldEnd called, sessionManager exists:', !!this.sessionManager);\n    if (this.sessionManager) {\n      this.sessionManager.setVadEnabled(true);\n    } else {\n      console.log('[App] No sessionManager available');\n    }\n  }\n\n  private async initializeServices(siteUrl: string, bearerToken: string): Promise<void> {\n    const apiService = new ApiService(siteUrl, bearerToken);\n\n    // Only test connection when actually needed\n    // This will throw if credentials are invalid\n    await apiService.testConnection();\n\n    this.apiService = apiService;\n    this.audioService = new AudioService(apiService);\n    this.sessionManager = new SessionManager(\n      this.stateManager,\n      apiService,\n      this.elements.remoteAudio\n    );\n  }\n}\n","import { AppState, AppStatus, Message, ToolCall } from '@/types';\nimport { STORAGE_KEYS } from '@/utils/constants';\n\nexport class StateManager {\n  private state: AppState;\n  private listeners: Array<(state: AppState) => void> = [];\n\n  constructor() {\n    this.state = {\n      siteUrl: localStorage.getItem(STORAGE_KEYS.SITE_URL) || '',\n      username: localStorage.getItem(STORAGE_KEYS.USERNAME) || '',\n      bearerToken: null,\n      sessionToken: null,\n      status: 'disconnected',\n      messages: [],\n      currentTranscript: '',\n      peerConnection: null,\n      dataChannel: null,\n      localStream: null,\n      toolCallQueue: [],\n      currentToolCallId: null,\n      isCustomTtsEnabled: false,\n      sessionModalities: [],\n      isPlayingCustomTts: false,\n    };\n  }\n\n  getState(): AppState {\n    return this.state;\n  }\n\n  setState(updates: Partial<AppState>): void {\n    this.state = { ...this.state, ...updates };\n    this.notifyListeners();\n  }\n\n  updateStatus(status: AppStatus): void {\n    this.setState({ status });\n  }\n\n  addMessage(message: Message): void {\n    this.setState({ messages: [...this.state.messages, message] });\n  }\n\n  clearMessages(): void {\n    this.setState({ messages: [] });\n  }\n\n  setSiteConfig(siteUrl: string, username: string, bearerToken: string): void {\n    this.setState({ siteUrl, username, bearerToken });\n    localStorage.setItem(STORAGE_KEYS.SITE_URL, siteUrl);\n    localStorage.setItem(STORAGE_KEYS.USERNAME, username);\n  }\n\n  clearSiteConfig(): void {\n    this.setState({ siteUrl: '', username: '', bearerToken: null });\n    localStorage.removeItem(STORAGE_KEYS.SITE_URL);\n    localStorage.removeItem(STORAGE_KEYS.USERNAME);\n    localStorage.removeItem(STORAGE_KEYS.APP_PASSWORD);\n  }\n\n  setSessionData(sessionToken: string, modalities: string[]): void {\n    const isCustomTtsEnabled = !modalities.includes('audio');\n    this.setState({ sessionToken, sessionModalities: modalities, isCustomTtsEnabled });\n  }\n\n  updateTranscript(transcript: string): void {\n    this.setState({ currentTranscript: transcript });\n  }\n\n  appendTranscript(delta: string): void {\n    this.setState({ currentTranscript: this.state.currentTranscript + delta });\n  }\n\n  queueToolCall(toolCall: ToolCall): void {\n    this.setState({ toolCallQueue: [...this.state.toolCallQueue, toolCall] });\n  }\n\n  dequeueToolCall(): ToolCall | undefined {\n    const [toolCall, ...rest] = this.state.toolCallQueue;\n    this.setState({ toolCallQueue: rest, currentToolCallId: toolCall?.call_id || null });\n    return toolCall;\n  }\n\n  setPlayingCustomTts(isPlaying: boolean): void {\n    this.setState({ isPlayingCustomTts: isPlaying });\n  }\n\n  subscribe(listener: (state: AppState) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach((listener) => listener(this.state));\n  }\n}\n","import { App } from './components/App';\nimport { StateManager } from './services/StateManager';\nimport { initializeElements } from './utils/dom';\nimport './styles/main.css';\n\n// Initialize the application when DOM is ready\ndocument.addEventListener('DOMContentLoaded', async () => {\n  const elements = initializeElements();\n  const stateManager = new StateManager();\n  const app = new App(elements, stateManager);\n\n  try {\n    await app.init();\n  } catch (error) {\n    console.error('Failed to initialize app:', error);\n  }\n});\n","import { UIElements } from '@/types';\n\nexport function initializeElements(): UIElements {\n  return {\n    configScreen: document.getElementById('configScreen') as HTMLElement,\n    mainApp: document.getElementById('mainApp') as HTMLElement,\n    configForm: document.getElementById('configForm') as HTMLFormElement,\n    siteUrlInput: document.getElementById('siteUrl') as HTMLInputElement,\n    usernameInput: document.getElementById('username') as HTMLInputElement,\n    appPasswordInput: document.getElementById('appPassword') as HTMLInputElement,\n    configError: document.getElementById('configError') as HTMLElement,\n    connectBtn: document.getElementById('connectBtn') as HTMLButtonElement,\n    settingsBtn: document.getElementById('settingsBtn') as HTMLButtonElement,\n    settingsMenu: document.getElementById('settingsMenu') as HTMLElement,\n    changeConfigBtn: document.getElementById('changeConfigBtn') as HTMLElement,\n    logoutBtn: document.getElementById('logoutBtn') as HTMLElement,\n    micButton: document.getElementById('micButton') as HTMLButtonElement,\n    statusText: document.getElementById('statusText') as HTMLElement,\n    chatContainer: document.getElementById('chatContainer') as HTMLElement,\n    emptyState: document.getElementById('emptyState') as HTMLElement,\n    remoteAudio: document.getElementById('remoteAudio') as HTMLAudioElement,\n    loadingOverlay: document.getElementById('loadingOverlay') as HTMLElement,\n  };\n}\n"],"names":["API_ENDPOINTS","OPENAI_API","AUDIO_CONFIG","UI_CONFIG","STORAGE_KEYS","STATUS_MESSAGES","ERROR_MESSAGES","ApiService","constructor","siteUrl","bearerToken","this","testConnection","__async","response","fetch","method","mode","credentials","headers","Authorization","ok","status","Error","userData","json","id","name","console","log","jsonError","createSession","body","JSON","stringify","error","text","sessionData","_a","client_secret","value","executeTool","request","getTextToSpeech","blob","generateBearerToken","username","appPassword","btoa","WebRTCService","peerConnection","dataChannel","localStream","startSession","_0","arguments","sessionToken","model","callbacks","RTCPeerConnection","onTrack","ontrack","getTransceivers","forEach","t","sender","track","kind","params","getParameters","encodings","maxBitrate","setParameters","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","sampleSize","echoCancellation","noiseSuppression","autoGainControl","getTracks","addTrack","createDataChannel","ordered","onDataChannelOpen","onopen","onDataChannelMessage","onmessage","onDataChannelError","onerror","offer","createOffer","setLocalDescription","sdpResponse","sdp","answerSdp","setRemoteDescription","type","sendEvent","event","readyState","send","muteMicrophone","getAudioTracks","enabled","unmuteMicrophone","updateTurnDetection","session","turn_detection","threshold","prefix_padding_ms","silence_duration_ms","closeSession","stop","close","AudioService","apiService","isMobileAudioUnlocked","globalAudioContext","isPlayingCustomTts","currentAudioElement","unlockMobileAudio","audioElement","window","AudioContext","webkitAudioContext","state","resume","warn","wasMuted","muted","playPromise","play","then","pause","currentTime","catch","err","playCustomTtsAudio","onStart","onEnd","audioBlob","size","dataset","objectUrl","URL","revokeObjectURL","srcObject","createObjectURL","src","Promise","resolve","reject","checkInterrupted","onended","intervalId","setInterval","clearInterval","originalResolve","interruptCustomTts","cleanup","isPlayingTts","SessionManager","stateManager","webrtcService","audioService","setState","messages","toolCallQueue","currentToolCallId","setSessionData","modalities","includes","updateStatus","handleServerEvent","handleError","streams","e","message","stopSession","getState","updateTranscript","setVadEnabled","data","parse","addMessage","content","transcript","appendTranscript","delta","isCustomTtsEnabled","handleResponseDone","responseOutput","_d","output","_b","_c","responseText","playCustomTts","outputItem","call_id","queueToolCall","toolCall","dequeueToolCall","processToolCall","setPlayingCustomTts","result","tool_name","sendFunctionResult","nextToolCall","callId","item","interruptTts","UIController","elements","typingMessageDiv","showConfigScreen","configScreen","style","display","mainApp","classList","remove","showMainApp","add","showError","configError","textContent","setTimeout","showLoading","show","loadingOverlay","toggleSettingsMenu","settingsMenu","toggle","hideSettingsMenu","clearMessages","chatContainer","innerHTML","appendChild","emptyState","parentNode","messageDiv","document","createElement","className","bubbleDiv","scrollTop","scrollHeight","showTypingIndicator","updateTypingMessage","bubble","querySelector","hideTypingIndicator","hasTypingIndicator","populateConfigForm","siteUrlInput","usernameInput","appPasswordInput","clearConfigForm","disableConnectButton","disabled","connectBtn","MicButtonController","buttonElement","statusElement","currentState","pressTimer","isPressAndHold","pressStartTime","PRESS_HOLD_DELAY","MIN_CLICK_TIME","setupEventListeners","addEventListener","handleClick","handlePressStart","handlePressEnd","handlePressCancel","passive","preventDefault","Date","now","onPressAndHoldStart","pressDuration","clearTimeout","onPressAndHoldEnd","_e","onStartRecording","onInterruptTts","onStopRecording","newState","options","updateUI","getMicIcon","getSoundWaveIcon","getStopIcon","App","sessionManager","lastMessageCount","uiController","micController","micButton","statusText","startRecordingSession","stopRecordingSession","handlePressAndHoldStart","handlePressAndHoldEnd","init","subscribe","onStateChange","configForm","handleConfigSubmit","settingsBtn","stopPropagation","changeConfigBtn","logoutBtn","handleLogout","remoteAudio","once","contains","target","currentTranscript","length","slice","msg","storedPassword","localStorage","getItem","url","trim","protocol","startsWith","cleanUrl","replace","setSiteConfig","setItem","initializeServices","confirm","clearSiteConfig","StateManager","listeners","sessionModalities","updates","__spreadValues","notifyListeners","removeItem","rest","isPlaying","listener","push","filter","l","exports","getElementById","app"],"mappings":"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"}